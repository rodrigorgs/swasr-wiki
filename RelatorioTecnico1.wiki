<wiki:comment>

O desenvolvimento de software é uma atividade complexa, etc. e tal. Dijkstra disse que para lidar com essa complexidade deve-se decompor os problemas em problemas menores, refinamentos sucessivos. Desde então esse mecanismo de abstração foi incorporado nas linguagens de programação, com o advento da programação estruturada, seguida pela programação orientada a objetos e, mais recentemente, a programação orientada a aspectos. Essa decomposição certamente é útil para diminuir a complexidade do desenvolvimento de software, uma vez que permite dividir a tarefa de desenvolvimento em pedaços intelectualmente assimiláveis, mas faz emergir uma complexa rede de interações entre esses componentes.

Compreender a maneira como os componentes são interconectados é de grande importância para entender os internos de um software e tirar conclusões sobre seu desenvolvimento. Dois componentes que não interagem entre si podem ser desenvolvidos por duas equipes trabalhando independentemente, sem necessidade de comunicação entre membros de equipes distintas: o funcionamento de um componente não depende do bom funcionamento do outro. Se, no entanto, um componente A precisa de um componente B para funcionar corretamente, um mau funcionamento de B pode causar falhas no componente A.

Essa rede de relacionamentos é usada em análise de impacto de mudanças em software, na divisão de trabalho entre equipes. Curiosamente redes de software de larga escala exibem padrões marcantes, que parecem não depender da linguagem de programação ou da metodologia usada durante o desenvolvimento.

Vamos entender de que forma um programa orientado a objetos é estruturado, as formas como os componentes  interagem entre si e como essas interações podem ser extraídas a partir do código-fonte do programa. A partir daí mostraremos que passos já foram dados na determinação de um modelo da rede de dependências de software.

= A topologia de um programa =

Todo programa é dividido em componentes que se relacionam a fim de resolver um problema. Componente, neste caso, é um conceito cujo significado concreto depende do paradigma de programação. Na programação estruturada, esses componentes são os procedimentos e as funções; na programação orientada a objetos, são classes (que, por sua vez, são decompostas em métodos e atributos). Neste texto nos concentraremos na programação orientada a objetos.

As formas de interação entre componentes podem ser classificadas em dois tipos: transferência de controle e transferência de dados. A transferência de controle ocorre, por exemplo, quando um objeto em execução chamada um método de outro objeto, efetivamente causando a execução de código presente no outro objeto. A transferência de dados pode ocorrer quando parâmetros estão associados a uma chamada de método, ou quando dois objetos compartilham o acesso a um arquivo.

Essa rede de relacionamentos pode ser modelada como um grafo orientado, onde os vértices representam os componentes e os arcos representam as interações entre os componentes. Vértices e arcos podem ter metadados associados a eles a fim de detalhar o que eles representam. Um vértice pode representar uma classe, um método ou um atributo, enquanto um arco pode representar a chamada de um método, a leitura de um atributo, entre outros.

A rede de dependências entre componentes de um programa pode ser extraída automaticamente por um programa construído para este fim, denominado extrator. As duas técnicas de extração mais comum são a análise dinâmica e a análise estática. A análise dinâmica consiste em instrumentar o programa sob análise e então coletar dados sobre sua execução. Esse tipo de análise exige que o programa esteja corretamente instalado e configurado e depende da sua execução completa.

Análise estática é o nome dado à análise de um programa sem a sua execução. As interações entre os componentes são extraídas a partir do código-fonte ou do código objeto do programa analisado.

Os dois tipos de análise diferem quanto ao conjunto de relacionamentos que são capazes de extrair de um programa, e mesmo duas técnicas de um mesmo tipo podem fornecer resultados distintos. Um estudo comparativo entre extratores pode ser encontrado em XXX. 

Em qualquer caso é impossível garantir que todas as dependências foram extraídas. O problema de determinar se existe uma relação de dependência entre dois componentes é indecidível XXX. Basta considerar o uso de ponteiros em linguagens como C++, ou a transferências de dados através de arquivos (Undecidability of static analysis). Assim, o resultado de qualquer ferramenta de análise de programas deve ser considerado apenas uma aproximação da realidade.

// A Figura 1 mostra uma rede.
// A Figura 2 mostra uma rede simplificada.

// filtragem, simplificação
Em muitos casos se deseja 
Em qualquer caso, a rede de dependências encontrada pode ser mais complexa do que o desejado. 

A way to understand natural and artificial systems is by means of looking at the structure of the relationships between their constituting components. (Valverde, Architecture) Estudos recentes revelaram regularidades entre redes como a Web, cadeias alimentares, circuitos eletrônicos, ligações entre proteínas e relacionamentos sociais.

O código-fonte de um programa orientado a objetos é decomposto em classes, e cada classe possui métodos e atributos. Em algumas linguagens de programação as classes são organizadas em pacotes ou módulos. PESQUISAR ALGUMA FONTE SOBRE PROGRAMAÇÃO ORIENTADA A OBJETOS.

    Além disso, características inerentes a sistemas orientados a objetos, como o polimorfismo, a ligação dinâmica, a herança e o encapsulamento contribuem diretamente para tornar a tarefa da análise de impacto ainda mais dispendiosa. O polimorfismo e a ligação dinâmica permitem que objetos diferentes sejam usados através de suas interfaces, o que será definido somente em tempo de execução. Com o encapsulamento, os objetos ocultam suas implementações, restringindo a forma de observá-los; apenas seus métodos públicos são visíveis. Já com a herança, uma mudança na superclasse pode ou não afetar a subclasse, o que complica a tarefa de analisar o impacto quando uma superclasse é modificada.

// Tipos de dependências: página 29 da diss. de Lile.

Entidades: método, classe, ...
Tipos de relacionamento: chama, estende, lê, altera, 
Significado da dependência (importância na engenharia de software): não dá pra usar um sem o outro, o funcionamento correto de um é necessário para o funcionamento correto de outro, propagação de bugs, distribuição independente, desenvolvimento independente (ver anotação no meu gmail)...
Lifting para o nível de classes

= Redes complexas =

// CDN: rede de dependências entre componentes.
Alguns usam direcionado, outros não, alguns usam apenas agregação, alguns usam peso, alguns descartam componentes de bibliotecas, etc.

// Propriedades globais, macroscópias, da estrutura de relacionamentos entre entidades de software.

A teoria das redes complexas estuda propriedades gerais de diversos tipos de redes com o uso de ferramentas estatísticas. Na última década foram realizados estudos sobre redes tecnológicas, como a Web e a rede de distribuição de energia elétrica dos Estados Unidos, redes biológicas como cadeia alimentar e ligações entre proteínas da bactéria XXX, e redes sociais como ....

O primeiro modelo que tentou explicar como são formadas as redes foi o modelo de Erdös-Rényi, também chamado de modelo de rede aleatória. Nesse modelo, é construído um conjunto de N vértices e a probabilidade de um par de vértices possuir uma aresta é constante e igual a p. É possível demonstrar analiticamente que o grau médio de um grafo aleatório é dado por <k> = p(n - 1). Quando N é muita grande, a distribuição das probabilidades dos graus é bem aproximada pela distribuição de Poisson.

Poisson:
P(k)  =~ (z^k * e^-z) / k!  , onde z = <k> = p(n - 1) // NEWMAN, p. 21, the structure and function of complex networks



Cada vértice em um grafo é caracterizado por um grau, k, que representa a quantidade de arcos ligados a ele. No caso de grafos orientados, existe a distinção entre grau de saída e grau de entrada, que representam a quantidade de arestas que saem ou entram, respectivamente, do vértice.

Em 1999, Barabási e Albert analisaram um grafo representando uma porção da Web, no qual os vértices representam páginas e as arestas representam os links entre duas páginas. Eles consideram o modelo simplificado de um grafo não-orientado. Agrupando os vértices de acordo com o grau e então plotando o gráfico da distribuição da quantidade de vértices por grau, eles encontraram uma curva que podia ser aproximada por uma lei de potência. Formalmente, a probabilidade de um vértice escolhido ao acaso possuir grau k, P(k), era tal que P(k) = Ck^-gamma (C é um coeficiente de normalização, cujo objetivo é fazer com que a soma das probabilidades seja igual a 1). Essa função é dita livre de escala, pois P(ak) = bP(k) - a mudança de escala da variável dependente não altera a variável independente a menos de um fator multiplicativo. Esse resultado foi surpreendente, pois eles esperavam encontrar distribuição de graus Poissoniana, que caracteriza as redes aleatórias. Desde então foram encontradas distribuições de graus livres de escala em redes biológicas, sociais e tecnológicas, incluindo redes de dependências entre componentes de programas de computador.

Propriedades estatísticas da lei de potência. A Figura 1(a) mostra o gráfico de uma lei de potência. Intuitivamente, percebe-se que a grande maioria dos vértices possui um grau pequeno, mas existem vértices cujo grau está muito acima do grau médio. Trata-se de uma curva assimétrica positiva, pois a média é maior do que a mediana. Embora existam poucos elementos cujo valor é alto, o valor deles é tão alto que contribui para elevar a média. A média não é um valor muito representantivo: basta notar que o desvio-padrão é muito grande (maior do que a média???).

Trata-se de uma curva assimétrica positiva,


// Obviamente existem inúmeras variações sobre o conceito de grafo. Os relacionamentos entre vértices podem ser simétricos, mas também podem ser assimétricos, e nesse último caso chamamos a estrutura de grafo direcionado ou dígrafo. É possível enriquecer o modelo associando atributos a vértices e arestas. Pode-se conceber que existem vários tipos de vértices, e vários tipos de arestas. Também é comum associar a cada aresta um número, denominado peso da aresta, que indica o quão fortemente relacionados estão os vértices que a compartilham.



A distribuição de graus é bastante heterogênea

Definições de teoria dos grafos. Vértice, aresta. Grafo, dígrafo... nós adjacentes, sucessores, predecessores. Grafo ponderado. Grafo rotulado... Multigrafo (várias arestas entre dois vértices)
Propriedades de vértices:
* grau (total, de entrada, de saída)
* coeficiente de agrupamento (ou aglomeração)
Outras: distância, coeficiente de assortatividade

Propriedades estatísticas globais (redes complexas):
* efeito mundo pequeno
* distribuição de graus
* correlação de graus
* distribuição do coeficiente de agrupamento
* distância geodésica média
* diâmetro

Outros: motifs

hubs, concentradores (noção informal)

Modelos: aleatório, mundo pequeno, livre de escala
efeito mundo pequeno: distância geodésica média cresce com o logaritmo do tamanho
lei de potência
conexão preferencial

= Redes complexas em software =

São redes de informação, redes tecnológicas (segundo Newman2003) e redes projetadas pelo homem.

Não há uma definição única de rede de software. Alguns consideram apenas agregação e herança, outros consideram chamadas... Alguns consideram o grafo orientado, outros não orientado...

Nem todos os trabalhos usam a Estatística rigorosamente. Lognormal, double pareto, power law, stretched exponential, power law with exponential cutoff...

</wiki:comment>
